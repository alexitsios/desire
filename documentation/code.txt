FOLDERS:
    /Base - Contains all the base classes (ItemBase, for inventory items; NPCBase, for NPCs; PropBase, for items you can interact in the world)
    /Enums - Contains all the enums used throughout the code
    /Interfaces - Contains all Interfaces
    /NPCs - Contains the individual implementations for each NPC. Those NPCs will most likely inherit NPCBase, having access to movement and interactability
    /Player - Contains all the scripts related to the player character, like inventory, interaction, movement, etc.
    /Props - Contains the individual implementations for each Prop. Those props will most likely inherit PropBase, having access to interactability

INTERACTIONS:
    To allow interactions, an object (Prop, NPC, or anything else) needs to implement the interface IInteractable. After implementing the Flowchart parameter, you can create a 
    public void Interact(), detailing inside it what exactly will happen when an interaction occurs. On the player side, every time the player left-clicks, the script PlayerInteraction
    checks all Colliders colliding with the player Action Area (a BoxCollider2D determining the area the player can interact with). If the clicked object is inside this area AND
    is a IInteractable, the player interacts with it. 
    
    Since each interactable object implements the Interact() method from the interface, the script doesn't need to now exactly what kind of object is being interacted with, or what will happen.
    All of this logic is controlled by the object

INVENTORY:
    For now, the inventory is a List of IventoryItem objects. Each object is a Prefab with an IventoryItem script component, and this scripts contains two major variables: the item type (an Enum, with 
    each value representing a different collectible item), and the item sprite. All of the inventory logic (adding or removing items, selecting items, etc.) is controlled by the class PlayerInventory.
    The inventory screen is an UI element (saved in another scene because Unity's UI workflow is a nightmare), and the inventory scripts sends the inventory List whenever the screen needs to be updated.
    Appart from some simple methods, the inventory is non-functional

SETTING UP NEW INTERACTIONS:
    Create a new empty Game Object and name it whatever you like. Add a 2D Collider, and set it's dimensions to the appropriate values. If the object has a sprite, add a Sprite Renderer as well.
    Create a new script, with a name equal to the Game Object's name, change the ": MonoBehaviour" part for the appropriate base class, depending on the type of interaction you're creating (the
    options are NPCBase, ItemBase, and PropBase. You can create new ones, but I don't think it's necessary). All three of the base classes have an Interact method that needs to be overriden, so
    delete the Start and Update methods (unless you need them) and add a "public override void Interact(ItemType item)". The base classes have a public variable called "Flowchart" that you can use to 
    access the appropriate flowchart. The ItemBase class has a public variable called "_playerInventory" that you can use to access the player's inventory (to add or remove items).
    The "item" parameter tells the method which item (if any) was selected by the player when the object was clicked

    After the script is created, add it to the object you created earlier. Open the appropriate flowchart and add a new block. The last thing this new block should do is call a FinishConversation
    block, to tell the Game Manager the interaction is over. If you're creating an interaction in a scene where the needed flowchart doesn't exist, you can create it (but you MUST name it NPCsFlowchart,
    PropsFlowchart, or ItemsFlowchart. The name is case-sensitive and is used by the base classes to set up the Flowchart variable). After this point, the interaction should already be working

    Note: if all the created object does when interacted with is call a block (and nothing else), you can simply add a base class script (PropBase, ItemBase, NPCBase) to it. Make sure the name of the 
    object matches the name of the block

    Here's a list of needed steps:

    - Create object
    - Add 2D Collider
    - (Optional) Add Sprite Renderer
    - Create script that inherits the appropriate base class
    - Override the Interact method
    - Add the script to the object
    - (Optional) Create new flowchart named NPCsFlowchart, ItemsFlowchart, or PropsFlowchart
    - Create new block in appropriate flowchart
    - Set up the new block
    - Connect new block to the FinishInteraction block

QUEST SYSTEM:
    The GameManager has a script attached to it called QuestController. Inside this script, there's a public variable called Quests, containing all the quests in the game. A quest is defined as a 
    pair of enums (QuestName and QuestStatus). The first is a list of all quests available, and the second is the quest's current status (completed, failed, active, inactive, etc.). Because of this,
    the Quests variable is a Dictionary, and the status of a quest can be accesses by "Quests[questName]". Inside this class you'll also find a public method to update the status of a quest. This can
    be used by other classes, as well as Flowcharts, to update quests whenever the player do something.

    To add a new quest to the game, simply add a new entry on the QuestName enum. It'll be automatically added to the GameManager when the game starts. The quests's requirements, as well as win/fail
    conditions must be implemented manually, unfortunately